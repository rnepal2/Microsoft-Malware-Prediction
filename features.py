# libraries
import time
import random
import numpy as np

# let us implement the features into some of the columns
# columns to consider: 
# based on the correlation with Target: let us consider following 
# columns with only at least 1% correlation with Target
# Definitely after some of the columns already dropped by other limitations.
# 30 columns left including target: 29 feature classes
'''
Column Name:										Correlation with HasDetections

HasDetections                                        1.000000
AVProductsInstalled                                  0.149717
AVProductStatesIdentifier                            0.117435
Census_IsAlwaysOnAlwaysConnectedCapable              0.063192
IsProtected                                          0.057416
Census_TotalPhysicalRAM                              0.057402
Census_ProcessorCoreCount                            0.054629
Wdft_IsGamer                                         0.054059
Census_IsVirtualDevice                               0.051560
Census_PrimaryDiskTotalCapacity                      0.048853
RtpStateBitfield                                     0.041572
AVProductsEnabled                                    0.041527
Census_IsTouchEnabled                                0.040514
IsSxsPassiveMode                                     0.035033
Census_InternalPrimaryDiagonalDisplaySizeInInches    0.035020
Census_InternalPrimaryDisplayResolutionHorizontal    0.032356
Census_OSBuildNumber                                 0.029793
Census_FirmwareManufacturerIdentifier                0.026465
OsBuild                                              0.025148
Census_ProcessorModelIdentifier                      0.022894
Wdft_RegionIdentifier                                0.022286
OsSuite                                              0.021510
Census_InternalBatteryNumberOfCharges                0.020571
Census_HasOpticalDiskDrive                           0.019870
Census_InternalBatteryType                           0.019533
Census_IsPenCapable                                  0.016225
IeVerIdentifier                                      0.015938
Census_OEMNameIdentifier                             0.015036
Census_InternalPrimaryDisplayResolutionVertical      0.014621
SMode                                                0.014274
Census_SystemVolumeTotalCapacity                     0.014067
'''

'''
extras columns:

Processor
OsPlatformSubRelease
Census_OSArchitecture
Census_OSSkuName
Census_OSWUAutoUpdateOptionsName
Census_OSEdition
'''


# feed train_df and test_df after dropping unnecessary columns and 
# NaN imputation
def engineer_features(train_df, test_df):
	# Let us create a list: to append the column names modified
	columns_treated = []
	# AVProductsInstalled
	train_df['AVProductsInstalled'] = train_df['AVProductsInstalled'].apply(lambda x: x if x in [1., 2., 3.] else 1.0)
	train_df['AVProductsInstalled'] = train_df['AVProductsInstalled'].astype('category') 

	test_df['AVProductsInstalled'] = test_df['AVProductsInstalled'].apply(lambda x: x if x in [1., 2., 3.] else 1.0)
	test_df['AVProductsInstalled'] = test_df['AVProductsInstalled'].astype('category')
	columns_treated.append('AVProductsInstalled')

	# AVProductStatesIdentifier
	# this column has 5489 categories: let's keep only top 50: (rest are only for machines less than 100.)
	# replace rest with either of the two high frequency categories: 53447.0  or 7945.0 : RULE:
	# actually I don't wanna create a rule here: because I will not know about test 'HasDetections', so let 
	# us do randomly into either of this classes

	categories = train_df['AVProductStatesIdentifier'].unique()[:50]
	replacements = [53447.0, 7945.0]
	def replace(x):
		return replacements[random.randint(0,1)]

	train_df['AVProductStatesIdentifier'] = train_df['AVProductStatesIdentifier'].apply(lambda x: x if x in categories else replace(x))
	train_df['AVProductStatesIdentifier'] = train_df['AVProductStatesIdentifier'].astype('category')

	categories = test_df['AVProductStatesIdentifier'].unique()[:50]
	test_df['AVProductStatesIdentifier'] = test_df['AVProductStatesIdentifier'].apply(lambda x: x if x in categories else replace(x))
	test_df['AVProductStatesIdentifier'] = test_df['AVProductStatesIdentifier'].astype('category')
	columns_treated.append('AVProductStatesIdentifier')
	
	# Census_IsAlwaysOnAlwaysConnectedCapable
	train_df['Census_IsAlwaysOnAlwaysConnectedCapable'] = train_df['Census_IsAlwaysOnAlwaysConnectedCapable'].astype('int8')
	test_df['Census_IsAlwaysOnAlwaysConnectedCapable'] = test_df['Census_IsAlwaysOnAlwaysConnectedCapable'].astype('int8')
	columns_treated.append('Census_IsAlwaysOnAlwaysConnectedCapable')
	
	# IsProtected
	train_df['IsProtected'] = train_df['IsProtected'].astype('int8')
	test_df['IsProtected'] = test_df['IsProtected'].astype('int8')
	columns_treated.append('IsProtected')

	# Census_TotalPhysicalRAM
	categories = train_df['Census_TotalPhysicalRAM'].unique()[:20]
	replacements = categories[:3]
	def replace(x):
		return replacements[random.randint(0,2)]
	train_df['Census_TotalPhysicalRAM'] = train_df['Census_TotalPhysicalRAM'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_TotalPhysicalRAM'] = train_df['Census_TotalPhysicalRAM'].astype('category')
	test_df['Census_TotalPhysicalRAM'] = test_df['Census_TotalPhysicalRAM'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_TotalPhysicalRAM'] = test_df['Census_TotalPhysicalRAM'].astype('category')
	columns_treated.append('Census_TotalPhysicalRAM')

	# Census_ProcessorCoreCount
	categories = train_df['Census_ProcessorCoreCount'].unique()[:5]
	replacements = categories[:2]
	def replace(x):
		return replacements[random.randint(0,1)]
	train_df['Census_ProcessorCoreCount'] = train_df['Census_ProcessorCoreCount'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_ProcessorCoreCount'] = train_df['Census_ProcessorCoreCount'].astype('int8')
	test_df['Census_ProcessorCoreCount'] = test_df['Census_ProcessorCoreCount'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_ProcessorCoreCount'] = test_df['Census_ProcessorCoreCount'].astype('int')
	columns_treated.append('Census_ProcessorCoreCount')

	# Wdft_IsGamer
	train_df['Wdft_IsGamer'] = train_df['Wdft_IsGamer'].astype('int8')
	test_df['Wdft_IsGamer'] = test_df['Wdft_IsGamer'].astype('int8')
	columns_treated.append('Wdft_IsGamer')

	# Census_IsVirtualDevice
	train_df['Census_IsVirtualDevice'] = train_df['Census_IsVirtualDevice'].astype('int8')
	test_df['Census_IsVirtualDevice'] = test_df['Census_IsVirtualDevice'].astype('int8')
	columns_treated.append('Census_IsVirtualDevice')

	# Census_PrimaryDiskTotalCapacity
	# This is a difficult class: 1133 categories:  I am keeping first 150 cats for now
	categories = train_df['Census_PrimaryDiskTotalCapacity'].unique()[:150]
	replacements = categories[:3]
	def replace(x):
		return replacements[random.randint(0,2)]
	train_df['Census_PrimaryDiskTotalCapacity'] = train_df['Census_PrimaryDiskTotalCapacity'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_PrimaryDiskTotalCapacity'] = train_df['Census_PrimaryDiskTotalCapacity'].astype('int16') # convert into GB?
	test_df['Census_PrimaryDiskTotalCapacity'] = test_df['Census_PrimaryDiskTotalCapacity'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_PrimaryDiskTotalCapacity'] = test_df['Census_PrimaryDiskTotalCapacity'].astype('int16')
	columns_treated.append('Census_PrimaryDiskTotalCapacity')

	#RtpStateBitfield
	categories = train_df['RtpStateBitfield'].unique()[:2]
	replacements = categories[:2]
	def replace(x):
		return replacements[random.randint(0,1)]
	train_df['RtpStateBitfield'] = train_df['RtpStateBitfield'].apply(lambda x: x if x in categories else replace(x))
	train_df['RtpStateBitfield'] = train_df['RtpStateBitfield'].astype('int8') # IS this category?
	test_df['RtpStateBitfield'] = test_df['RtpStateBitfield'].apply(lambda x: x if x in categories else replace(x))
	test_df['RtpStateBitfield'] = test_df['RtpStateBitfield'].astype('int8')
	columns_treated.append('RtpStateBitfield')

	# AVProductsEnabled
	# 5 categories, cat 4.0 can be replaced
	categories = np.array([ 1.0,  2.0,  0.0, 3.0])
	train_df['AVProductsEnabled'] = train_df['AVProductsEnabled'].apply(lambda x: x if x in categories else 3.0)
	train_df['AVProductsEnabled'] = train_df['AVProductsEnabled'].astype('int8') 
	test_df['AVProductsEnabled'] = test_df['AVProductsEnabled'].apply(lambda x: x if x in categories else 3.0)
	test_df['AVProductsEnabled'] = test_df['AVProductsEnabled'].astype('int8')
	columns_treated.append('AVProductsEnabled')

	# Census_IsTouchEnabled
	train_df['Census_IsTouchEnabled'] = train_df['Census_IsTouchEnabled'].astype('int8')
	test_df['Census_IsTouchEnabled'] = test_df['Census_IsTouchEnabled'].astype('int8')
	columns_treated.append('Census_IsTouchEnabled')

	# IsSxsPassiveMode
	train_df['IsSxsPassiveMode'] = train_df['IsSxsPassiveMode'].astype('int8')
	test_df['IsSxsPassiveMode'] = test_df['IsSxsPassiveMode'].astype('int8')
	columns_treated.append('IsSxsPassiveMode')

	# Census_InternalPrimaryDiagonalDisplaySizeInInches
	# many categories: 507
	categories = train_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'].unique()[:150]
	replacements = categories[:4]
	def replace(x):
		return replacements[random.randint(0,3)]
	train_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = train_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = train_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'].astype('category') 
	test_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = test_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = test_df['Census_InternalPrimaryDiagonalDisplaySizeInInches'].astype('category')
	columns_treated.append('Census_InternalPrimaryDiagonalDisplaySizeInInches')

	# Census_InternalPrimaryDisplayResolutionHorizontal
	# many categories: 507
	categories = train_df['Census_InternalPrimaryDisplayResolutionHorizontal'].unique()[:50]
	replacements = categories[:4]
	def replace(x):
		return replacements[random.randint(0,3)]
	train_df['Census_InternalPrimaryDisplayResolutionHorizontal'] = train_df['Census_InternalPrimaryDisplayResolutionHorizontal'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_InternalPrimaryDisplayResolutionHorizontal'] = train_df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype('category') 
	test_df['Census_InternalPrimaryDisplayResolutionHorizontal'] = test_df['Census_InternalPrimaryDisplayResolutionHorizontal'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_InternalPrimaryDisplayResolutionHorizontal'] = test_df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype('category')
	columns_treated.append('Census_InternalPrimaryDisplayResolutionHorizontal')

	# Census_OSBuildNumber
	# categories: 65
	categories = train_df['Census_OSBuildNumber'].unique()[:6]
	replacements = categories[:6]
	def replace(x):
		return replacements[random.randint(0,5)]
	train_df['Census_OSBuildNumber'] = train_df['Census_OSBuildNumber'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_OSBuildNumber'] = train_df['Census_OSBuildNumber'].astype('category') 
	test_df['Census_OSBuildNumber'] = test_df['Census_OSBuildNumber'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_OSBuildNumber'] = test_df['Census_OSBuildNumber'].astype('category')
	columns_treated.append('Census_OSBuildNumber')

	# Census_FirmwareManufacturerIdentifier
	# categories: 304
	categories = train_df['Census_FirmwareManufacturerIdentifier'].unique()[:50]
	replacements = categories[:6]
	def replace(x):
		return replacements[random.randint(0,5)]
	train_df['Census_FirmwareManufacturerIdentifier'] = train_df['Census_FirmwareManufacturerIdentifier'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_FirmwareManufacturerIdentifier'] = train_df['Census_FirmwareManufacturerIdentifier'].astype('category') 
	test_df['Census_FirmwareManufacturerIdentifier'] = test_df['Census_FirmwareManufacturerIdentifier'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_FirmwareManufacturerIdentifier'] = test_df['Census_FirmwareManufacturerIdentifier'].astype('category')
	columns_treated.append('Census_FirmwareManufacturerIdentifier')

	# OsBuild
	# categories = 51
	categories = train_df['OsBuild'].unique()[:7]
	replacements = categories[:7]
	def replace(x):
		return replacements[random.randint(0,6)]
	train_df['OsBuild'] = train_df['OsBuild'].apply(lambda x: x if x in categories else replace(x))
	train_df['OsBuild'] = train_df['OsBuild'].astype('category') 
	test_df['OsBuild'] = test_df['OsBuild'].apply(lambda x: x if x in categories else replace(x))
	test_df['OsBuild'] = test_df['OsBuild'].astype('category')
	columns_treated.append('OsBuild')

	# Wdft_RegionIdentifier
	train_df['IsSxsPassiveMode'] = train_df['IsSxsPassiveMode'].astype('category')
	test_df['IsSxsPassiveMode'] = test_df['IsSxsPassiveMode'].astype('category')
	columns_treated.append('Wdft_RegionIdentifier')

	# OsSuite
	# mostly two cats
	categories = train_df['OsSuite'].unique()
	replacements = categories[:2]
	def replace(x):
		return replacements[random.randint(0,1)]
	train_df['OsSuite'] = train_df['OsSuite'].apply(lambda x: x if x in categories else replace(x))
	train_df['OsSuite'] = train_df['OsSuite'].astype('int16') 
	test_df['OsSuite'] = test_df['OsSuite'].apply(lambda x: x if x in categories else replace(x))
	test_df['OsSuite'] = test_df['OsSuite'].astype('int16')
	columns_treated.append('OsSuite')

	# Census_InternalBatteryNumberOfCharges
	# mostly two cats
	categories = train_df['Census_InternalBatteryNumberOfCharges'].unique()[:5]
	replacements = categories[:2]
	def replace(x):
		return replacements[random.randint(0,1)]
	train_df['Census_InternalBatteryNumberOfCharges'] = train_df['Census_InternalBatteryNumberOfCharges'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_InternalBatteryNumberOfCharges'] = train_df['Census_InternalBatteryNumberOfCharges'].astype('int32') 
	test_df['Census_InternalBatteryNumberOfCharges'] = test_df['Census_InternalBatteryNumberOfCharges'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_InternalBatteryNumberOfCharges'] = test_df['Census_InternalBatteryNumberOfCharges'].astype('int32')
	columns_treated.append('Census_InternalBatteryNumberOfCharges')

	# Census_HasOpticalDiskDrive
	train_df['Census_HasOpticalDiskDrive'] = train_df['Census_HasOpticalDiskDrive'].astype('int8')
	test_df['Census_HasOpticalDiskDrive'] = test_df['Census_HasOpticalDiskDrive'].astype('int8')
	columns_treated.append('Census_HasOpticalDiskDrive')

	# Census_InternalBatteryType
	# need to change to Lithium ion or others?
	def replace_battery(x):
		x = str(x).lower()
		if 'li' in x:
			return 1
		else:
			return 0
	train_df['Census_InternalBatteryType'] = train_df['Census_InternalBatteryType'].apply(lambda x: replace_battery(x))
	test_df['Census_InternalBatteryType'] = test_df['Census_InternalBatteryType'].apply(lambda x: replace_battery(x))
	columns_treated.append('Census_InternalBatteryType')

	# Census_IsPenCapable
	train_df['Census_IsPenCapable'] = train_df['Census_IsPenCapable'].astype('int8')
	test_df['Census_IsPenCapable'] = test_df['Census_IsPenCapable'].astype('int8')
	columns_treated.append('Census_IsPenCapable')

	# SMode
	train_df['SMode'] = train_df['SMode'].astype('int8')
	test_df['SMode'] = test_df['SMode'].astype('int8')
	columns_treated.append('SMode')

	# Processor: 
	# categories: [x64, arm64, x86]
	train_df['Processor'] = train_df['Processor'].astype('category')
	test_df['Processor'] = test_df['Processor'].astype('category')
	columns_treated.append('Processor')
	
	# OsPlatformSubRelease
	# 9 categories
	train_df['OsPlatformSubRelease'] = train_df['OsPlatformSubRelease'].astype('category')
	test_df['OsPlatformSubRelease'] = test_df['OsPlatformSubRelease'].astype('category')
	columns_treated.append('OsPlatformSubRelease')
	
	# Census_OSArchitecture
	train_df['Census_OSArchitecture'] = train_df['Census_OSArchitecture'].astype('category')
	test_df['Census_OSArchitecture'] = test_df['Census_OSArchitecture'].astype('category')
	columns_treated.append('Census_OSArchitecture')
	
	# Census_OSSkuName
	categories = train_df['Census_OSSkuName'].unique(:5)
	replacements = categories[:5]
	def replace(x):
		return replacements[random.randint(0,4)]
	train_df['Census_OSSkuName'] = train_df['Census_OSSkuName'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_OSSkuName'] = train_df['Census_OSSkuName'].astype('category') 
	test_df['Census_OSSkuName'] = test_df['Census_OSSkuName'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_OSSkuName'] = test_df['Census_OSSkuName'].astype('category')
	columns_treated.append('Census_OSSkuName')
	
	# Census_OSWUAutoUpdateOptionsName
	train_df['Census_OSWUAutoUpdateOptionsName'] = train_df['Census_OSWUAutoUpdateOptionsName'].astype('category')
	test_df['Census_OSWUAutoUpdateOptionsName'] = test_df['Census_OSWUAutoUpdateOptionsName'].astype('category')
	columns_treated.append('Census_OSWUAutoUpdateOptionsName')
	
	# Census_OSEdition
	categories = train_df['Census_OSEdition'].unique(:9)
	replacements = categories[:9]
	def replace(x):
		return replacements[random.randint(0,8)]
	train_df['Census_OSEdition'] = train_df['Census_OSEdition'].apply(lambda x: x if x in categories else replace(x))
	train_df['Census_OSEdition'] = train_df['Census_OSEdition'].astype('category') 
	test_df['Census_OSEdition'] = test_df['Census_OSEdition'].apply(lambda x: x if x in categories else replace(x))
	test_df['Census_OSEdition'] = test_df['Census_OSEdition'].astype('category')
	columns_treated.append('Census_OSEdition')

	
	# delete the columns that are in the passed dataframes but not treated yet!
	print('Number of columns in train_df: ', len(columns_treated) + 1) 
	print('Lastly, deleting the columns that are not treated during feature engineering.')
	for column in train_df.columns.values:
		if column not in columns_treated or column != 'HasDetections':
			del train_df[column]
			print('%s is deleted from passed train_df.' % column)
	print('Number of columns in test_df: ', len(columns_treated))
	print('Note that train_df has target HasDetections column too.')
	for column in test_df.columns.values:
		if column not in columns_treated:
			del test_df[column]
			print('%s is deleted from passed test_df.' % column)
	
	# return the final train and test dataframes
	return train_df, test_df